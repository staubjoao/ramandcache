// acesso aleatorio
void aleatorio(int *acessos, int *ram, ElemCache *cache, int *modifica, int i)
{
  int mod, j, k, len, indiceCache, aux, z, x, ale;

  // verifico se o valor deve ser modificado
  if (modifica[i] == 0)
  {
    // não é modificado, imprimo um guia para validar a execução
    printf("Acesso ao valor, na RAM, %d no indice %d:\n", ram[acessos[i]], acessos[i]);
  }
  else
  {
    // é modificado, gera um numero aleatorio e imprimo um guia para validar a execução
    ale = randomInt(100, 1000 + LENRAM);
    printf("Acesso ao valor, na RAM, %d no indice %d, valor modificado é %d:\n", ram[acessos[i]], acessos[i], ale);
  }
  // resto da divisão do indice do acesso pelo tamanho do bloco
  mod = acessos[i] % BLOCO;
  // variavel que vai delimitar o for para preencher o bloco da cache
  len = (acessos[i] + BLOCO) - mod;
  // verifica o primeiro bloco não ocupado da cache, caso não exista retorna -1
  aux = verificaCache(cache);
  // varre a cache procurando o elemento que está na fila, caso ele esteja na cache
  // retorna o inidice que ele está que fica armazenado em z e em x o indice do bloco
  z = varreCache(cache, acessos[i], &x);

  // o elemento está na cache
  if (z > -1)
  {
    // verifico se esse elemento deve ser modificado
    if (modifica[i] == 1)
      // modifico o elemento e marca o elemento como modificado
      cache[z].elemento[x] = ale, cache[z].m[x] = 1;

    printf("Valor na cache %d:\n", cache[z].elemento[x]);
    // conto 1 hit
    hit++;
  }
  // o elemento ñ está na cache
  else
  {
    // se aux é maior que -1 significa que existe um bloco(s) disponivel na cache
    if (aux > -1)
    {
      // indiceCache vai receber o valor que vamos utilizar na cache
      indiceCache = aux;
      // define o bloco da cache como ocupado
      cache[indiceCache].ocupada = 1;
    }
    else
    {
      // indiceCache vai receber o valor que vamos utilizar na cache
      indiceCache = randomInt(0, LENCACHE - 1);
      // chama a função writeBack para atualizar os valores na RAM
      writeBack(cache, ram, indiceCache);
    }
    // j vai começar do primeiro indice do bloco da RAM e vai até o ultimo indice
    for (j = (acessos[i] - mod), k = 0; j < len; j++, k++)
    {
      // o bloco da cache vai receber os indices do bloco da RAM
      cache[indiceCache].indice[k] = j;
      // verifica se o elemento vai ser modificado e se está no elemento do bloco
      if (modifica[i] == 1 && acessos[i] == j)
      {
        // o elemento na cache vai receber um valor aleatorio
        cache[indiceCache].elemento[k] = ale;
        // marco que aquele elemento foi modificado
        cache[indiceCache].m[k] = 1;
      }
      else
      {
        // caso o elemento ñ precisa de modificação carrego o indice do bloco da RAM
        // no indice equivalente da cache
        cache[indiceCache].elemento[k] = ram[j];
      }
    }
    // conto um miss
    miss++;
  }
  // imprimo o estado atual da cache
  // imprimeCache(cache);
  // imprimo a quantidade de hit e miss
  printf("\nHIT: %d MISS: %d\n", hit, miss);
}